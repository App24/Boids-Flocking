// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Boid
{
    float3 position;
    float3 velocity;
    float3 acceleration;
    float3 dir;
    float3 color;
    uint listIndex;
    uint boidSettingIndex;
    uint boidGroup;
    uint flags;
    float3 targetPosition;
};

struct BoidCollisionData
{
    uint headingForCollision;
    float3 collisionAvoidDir;
};

struct BoidSettings {
    float minSpeed;
    float maxSpeed;
    float maxSteerForce;
    float viewRadius;
    float avoidanceRadius;
    float alignWeight;
    float cohesionWeight;
    float seperateWeight;
    float avoidCollisionWeight;
    float targetWeight;
};

RWStructuredBuffer<Boid> boids;
uint numBoids;

StructuredBuffer<BoidCollisionData> boidCollisionData;
StructuredBuffer<BoidSettings> boidSettings;

float deltaTime;

float3 ClampMagniute(in float3 v, float mag)
{
    float clampedLength = clamp(length(v), -mag, mag);
    v = normalize(v) * clampedLength;
    return v;
}

float3 SteerTowards(float3 vec, Boid boid, BoidSettings settings)
{
    if (length(vec) == 0)
        return vec;
    float3 v = normalize(vec) * settings.maxSpeed - boid.velocity;
    v = ClampMagniute(v, settings.maxSteerForce);
    return v;
}

void UpdateBoid(inout Boid boid, BoidSettings settings, BoidCollisionData collisionData, float3 flockCentre, uint numFlockmates, float3 avgFlockHeading, float3 avgAvoidanceHeading)
{
    float3 acceleration = 0;
    uint goToTarget = (boid.flags & 2) == 2;
    
    if (goToTarget) {
        float3 offsetToTarget = (boid.targetPosition - boid.position);
        acceleration += SteerTowards(offsetToTarget, boid, settings) * settings.targetWeight;
    }

    if (numFlockmates != 0)
    {
        float3 centre = flockCentre / numFlockmates;
        float3 cohesionPosition = centre - boid.position;
    
        acceleration += SteerTowards(avgFlockHeading, boid, settings) * settings.alignWeight;
        acceleration += SteerTowards(cohesionPosition, boid, settings) * settings.cohesionWeight;
        acceleration += SteerTowards(avgAvoidanceHeading, boid, settings) * settings.seperateWeight;
    }
    
    if (collisionData.headingForCollision)
    {
        acceleration += SteerTowards(collisionData.collisionAvoidDir, boid, settings) * settings.avoidCollisionWeight;
    }
    
    if(length(boid.velocity) == 0)
        boid.velocity = boid.dir * ((settings.minSpeed + settings.maxSpeed) / 2);
    float3 velocity = boid.velocity + (acceleration * deltaTime);
    float speed = length(velocity);
    speed = clamp(speed, settings.minSpeed, settings.maxSpeed);
    float3 dir = velocity / speed;
    velocity = dir * speed;
    
    boid.velocity = velocity;
    boid.dir = dir;
    boid.position += velocity * deltaTime;
}

[numthreads(256,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint numFlockmates = 0;
    float3 flockCentre = 0;
    float3 avgFlockHeading = 0;
    float3 avgAvoidanceHeading = 0;
    Boid boid = boids[id.x];
    BoidSettings settings = boidSettings[boid.boidSettingIndex];
    uint ignoreOtherBoids = (boid.flags & 1) == 1;
    for (uint i = 0; i < numBoids; i++)
    {
        Boid otherBoid = boids[i];
        if (boid.listIndex != otherBoid.listIndex && (ignoreOtherBoids && boid.boidGroup == otherBoid.boidGroup))
        {
            float3 offset = otherBoid.position - boid.position;
            float sqrDst = offset.x * offset.x + offset.y * offset.y + offset.z * offset.z;

            if (sqrDst < settings.viewRadius * settings.viewRadius)
            {
                numFlockmates += 1;
                flockCentre += otherBoid.position;
                avgFlockHeading += otherBoid.dir;

                if (sqrDst < settings.avoidanceRadius * settings.avoidanceRadius)
                {
                    avgAvoidanceHeading -= offset / sqrDst;
                }
            }
        }
    }
    
    UpdateBoid(boids[id.x], settings, boidCollisionData[boid.listIndex], flockCentre, numFlockmates, avgFlockHeading, avgAvoidanceHeading);
}
